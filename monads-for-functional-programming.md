---
authors: "Philip Wadler"
title: "Monads for functional programming"
date: "1993"
license: "CC BY-NC-SA 3.0"
link: "[homepages.inf.ed.ac.uk](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)"
---

# 함수형 프로그래밍을 위한 모나드 (작성중)

## 초록

이 논문은 모나드를 사용하여 함수형 프로그램을 구조화하는 방법을 설명합니다. 모나드는 다른 언어들에서 발견되는 효과(effect)를 시뮬레이션하기에 적합한 프레임워크를 제공합니다. 전역 상태, 예외 처리, 출력 또는 비결정성 등의 효과입니다. 세 가지 케이스 스터디를 통해 자세히 살펴볼 것입니다. 1) 모나드가 간단한 평가자 (simple evaluator) 를 수정하는 데 어떻게 도움이 되는지, 2) 모나드가 재사용 가능한 배열의 데이터 형식의 기반이 되는지, 3) 모나드를 사용하여 파서를 작성하는 방법에 대해 살펴보겠습니다.

## 1. 서론

저는 순수할까요, 아니면 순수하지 않을까요?
함수형 프로그래밍 커뮤니티는 두 가지 측면으로 나뉩니다. 순수 언어로서 Marinda0 와 Haksell 는 순수하고 간단한 람다 계산을 기반으로 합니다. 비순수 언어로서 Scheme 과 Standard ML 은 할당, 예외 또는 계속 진행이라는 수 많은 효과를 이용하여 람다 계산을 강화합니다. 순수 언어는 프로그래밍의 목적과 이유를 쉽게 파악할 수 있고, 게으른 평가 (Lazy Evaluation) 측면 에서 이득을 볼 수 있지만, 불순 언어는 수행 효율성의 이점을 제공하며 때때로 더 컴팩트한 표현을 가능하게합니다.

개념적 컴퓨팅 과학의 최근 발전, 특히 유형 이론과 범주 이론 분야에서, 순수한 분야와 비순수 분야의 이점을 통합하는 새로운 접근법을 제안하고 있습니다. 이 노트는 불순한 효과를 순수 함수적 언어로 통합하기 위해 모나드를 사용하는 방법을 설명합니다.

모나드는 카테고리 이론에서 나오는 개념으로, 모기(Moggi)가 프로그래밍 언어의 방식으로 의미론을 구조화하는 데 적용하였습니다[13,14]. 이 동일한 기술을 함수적 프로그램의 구조화에도 적용될 수 있습니다 [21,23].

모나드의 응용은 세 가지 사례 연구로 설명됩니다. 2장에서는 모나드를 사용하여 간단한 평가자(i.e. 평가자 Evaluator: 프로그래밍 언어를 컴파일 하는 과정에서 syntax tree 구조로부터 값과 행동을 생산해내는 평가-evaluation 이라고 하며 평가자 프로그램은 이러한 작업을 수행하는 프로그램일 일컫습니다) 를 구조화하여 수정하기 쉽게하는 방법을 보여준다. 3장에서는 모나드에 의해 충족되는 법을 설명한다. 4장에서는 순수 함수언어에서 업데이트 가능한 상태(updatable state)를 제공하는 오래된 문제에 대해 모나드를 이용한 새로운 해결책을 제시한다. 5장에서는 모나드를 재귀적으로 접근하는 파서를 만드는 문제에 적용하는 것을 다룬다. 이는 그 자체로도 흥미롭지만, 시퀀싱 (sequencing) 과 교체 (alternation) 이라는 프로그래밍의 중요한 두가지 개념에 대한 새로운 패러다임을 제시한다.

여기에서 제시하는 구조화 방법들은, 카테고리 이론으로 부터의 통찰력없이는 발견될 수 없었을 것이다. 하지만, 한번 발견되면 카테고리 이론을 사용하지 않고도 쉽게 표현하고 설명할 수 있다. 이 논문을 읽기 위해 카테고리 이론 지식이 필요하지 않다.

예제는 Haskell로 제공되지만, 이에 대한 배경지식은 필요 없습니다. 필요한 것은 순수, 비순수 함수형 프로그래밍의 기초에 대한 일반적인 지식입니다. 일반적인 배경지식에 대해서는 [3,12] 를 참조하십시오. 앞으로 언급할 언어는 Haskell [4], Miranda [20], Standard ML [11] 그리고 Scheme [17]입니다.

## 2. 모나드를 사용하여 평가자 (evaluator) 프로그램 만들기

함수형 언어는 모든 데이터 흐름이 명시적으로(explicit) 드러나는 장점이 있습니다. 그리고 때로는 너무나도 명시적이라는 것이 단점 입니다.

함수형 언어에서 프로그램은 식의 집합으로 작성됩니다. 명시적 데이터 흐름(explicit data flow)은 식의 값이 자유 변수(free variable)에만 의존할 수 있도록 보장합니다. 따라서 동등한 것끼리의 대체는 항상 유효하므로, 이러한 프로그램은 규명하기 쉽습니다. 명시적 데이터 흐름은 계산의 순서가 상관없기 때문에, 지연 평가(lazy evalutation)에 민감하게 됩니다.

명시적 데이터 흐름은 모듈화(modularity)에 대한 장단점을 모두 갖추고 있습니다. 데이터가 들어오고 나가는 것이 명확하고 접근할 수 있으므로 최대한 유연하기 때문에 궁극의 모듈성을 갖추고 있다고 라고 말할 수 있지만, 한편으로는 알고리즘의 본질이 데이터를 생성하는 지점에서 사용하는 지점까지 데이터를 요구하는 배관 (plumbing) 아래에 감춰져 있을 수 있기 때문에 최약의 모듈성을 갖추고 있다고 할 수 도 있습니다.

평가자 (evaluator) 프로그램을 순수 함수형 언어로 작성한다고 해봅시다.

- 함수의 오류 처리를 추가하기 위해서는, 오류를 확인하고 적절하게 처리하도록 함수 각각의 재귀적 호출(recursive call)을 수정해야합니다. 예외(exception)를 가지는 비순수 언어를 사용했더라면, 이런 변경 작업이 필요치 않았을 것입니다.
- 함수를 재귀적으로 호출할 때마다 연산의 횟수를 세어야 하기 때문에, 각각의 재귀 호출에서 적절하게 카운트를 전달해야 합니다. 그러한 카운트를 증가시키는 전역 변수를 가진 비순수 언어를 사용한다면, 이런 변경 작업이 필요치 않았을 것입니다.
- 해당 재귀적 호출에 트레이싱(tracing)을 추가하려면, 적절한 트레이싱을 전달하도록 각 재귀 호출을 수정해야 합니다. 출력을 사이드이펙트(side effect)로 작동시킬 수 있는 비순수 언어를 사용했다면 이러한 변경 작업이 필요하지 않습니다.

혹은 모나드를 사용할 수 도 있을 것입니다.
아래 내용들은 모나드를 사용하여 평가자 프로그램을 작성하는 방법을 보여줍니다. 위에서 언급한 변경 내용 대신, 모나드만을 재정의하고 일부 지역적인 변경만을 수행하면 됩니다.

이러한 프로그래밍 스타일을 통해 비순수 언어의 다양한 기능으로 제공하는 유연성을 일부분 가져올 수 있습니다. 또한 비순수한 기능을 갖추지 않았을때도 사용할 수 있습니다. 명시적 데이터에서 제공되는 유연성과 암시적 배관 연결(plumbing)에서 제공하는 간결성 사이의 긴장을 완전히 없앨 수는 없지만, 일부 개선할 수 는 있습니다.

아래에서는 간단한 용어들을 다루는 기초적인 평가자 프로그램을 만드는 것으로 시작하여, 예외, 상태 및 출력을 모사할 수 있는 변경 작업을 진행해 볼 것입니다. 이 과정에서 이 작업들의 공통점을 분석하고, 이들로부터 모나드의 개념을 추출해보고자 합니다. 그 다음 각각의 변경 작업들이 모나드 라는 프레임워크에 어떻게 잘 들어맞는지를 살펴볼 것입니다.

### 2.1 0번째 변경 작업: 간단한 평가자 프로그램

이 변경작업에서는 굉장히 단순한 Term 을 다루는 평가자 프로그램 다룹니다. (i.e. Term 은 아래와 같이 새롭게 정의한 약속어, 타입(Type) 이다.)
<image1>
Term 은 상수 Con a (a 는 정수) 또는 t 와 u 라는 또다른 Term 들로 이루어진 분수 Div t u (i.e. Div 는 Haksell 에서 나누기 함수이다.) 중 하나입니다. (i.e. t 와 u 가 또다른 Term 이기 때문에, 재귀적인 나누기를 수행하는 약속자라고 생각하면 될 것이다.)

이 Term 을 다루는 평가자는 아래와 같이 매우 간단합니다.
<image2>

eval 함수는 Term 을 정수로 변환합니다. Term 이 상수이면 상수가 반환됩니다. Term 이 분수 (Div t u) 이면 재귀적으로 하위 Term 이 평가되고 분수가 계산됩니다. 정수 나눗셈을 표현하기 위해 '÷'를 사용합니다.

아래는 Term 의 예시입니다.
<image3>
첫번째 eval 함수의 결과인 answer 는 ((1972 ÷ 2 ) ÷ 23 ))의 값인 42입니다. 기본 평가자는 오류 처리를 포함하지 않으므로 두번째 eval 함수의 값 error 의 결과는 undefined 입니다.

### 2.2 Variation one: Exceptions

오류 처리를 추가하고자 한다면, 위의 두 번째 예제에서 옳은 오류 메시지를 반환하도록 할 수 있습니다. 비순수 언어에서는 예외(exception)를 사용하여 이를 쉽게 이를 수행할 수 있습니다.

순수 언어로 예외 처리를 모방하기 위해서는 예외를 발생시킬 수 있는 연산을 나타내는 타입을 만들어야 한다.
<image4>
타입 M a 의 값은 Raise e 이거나 Return a 의 형식이다. e는 예외이고, a는 타입 a의 값이다. 관례상, a는 M a와 같이 타입 변수로도, Return a와 같이 그 타입의 값을 의미하는 변수로도 사용된다.

### 2.3 Variation two: State
