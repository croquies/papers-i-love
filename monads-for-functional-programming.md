---
authors: "Philip Wadler"
title: "Monads for functional programming"
date: "1993"
license: "CC BY-NC-SA 3.0"
link: "[homepages.inf.ed.ac.uk](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)"
---

# 함수형 프로그래밍을 위한 모나드 (작성중)

## 초록

이 논문은 모나드를 사용하여 함수형 프로그램을 구조화하는 방법을 설명합니다. 모나드는 다른 언어들에서 발견되는 효과(effect)를 시뮬레이션하기에 적합한 프레임워크를 제공합니다. 전역 상태, 예외 처리, 출력 또는 비결정성 등의 효과입니다. 세 가지 케이스 스터디를 통해 자세히 살펴볼 것입니다. 1) 모나드가 간단한 평가자 (simple evaluator) 를 수정하는 데 어떻게 도움이 되는지, 2) 모나드가 재사용 가능한 배열의 데이터 형식의 기반이 되는지, 3) 모나드를 사용하여 파서를 작성하는 방법에 대해 살펴보겠습니다.

## 1. 서론

저는 순수할까요, 아니면 순수하지 않을까요?
함수형 프로그래밍 커뮤니티는 두 가지 측면으로 나뉩니다. 순수 언어로서 Marinda0 와 Haksell 는 순수하고 간단한 람다 계산을 기반으로 합니다. 비순수 언어로서 Scheme 과 Standard ML 은 할당, 예외 또는 계속 진행이라는 수 많은 효과를 이용하여 람다 계산을 강화합니다. 순수 언어는 프로그래밍의 목적과 이유를 쉽게 파악할 수 있고, 게으른 평가 (Lazy Evaluation) 측면 에서 이득을 볼 수 있지만, 불순 언어는 수행 효율성의 이점을 제공하며 때때로 더 컴팩트한 표현을 가능하게합니다.

개념적 컴퓨팅 과학의 최근 발전, 특히 유형 이론과 범주 이론 분야에서, 순수한 분야와 비순수 분야의 이점을 통합하는 새로운 접근법을 제안하고 있습니다. 이 노트는 불순한 효과를 순수 함수적 언어로 통합하기 위해 모나드를 사용하는 방법을 설명합니다.

모나드는 카테고리 이론에서 나오는 개념으로, 모기(Moggi)가 프로그래밍 언어의 방식으로 의미론을 구조화하는 데 적용하였습니다[13,14]. 이 동일한 기술을 함수적 프로그램의 구조화에도 적용될 수 있습니다 [21,23].

모나드의 응용은 세 가지 사례 연구로 설명됩니다. 2장에서는 모나드를 사용하여 간단한 평가자(i.e. 평가자 Evaluator: 프로그래밍 언어를 컴파일 하는 과정에서 syntax tree 구조로부터 값과 행동을 생산해내는 평가-evaluation 이라고 하며 평가자은 이러한 작업을 수행하는 프로그램일 일컫습니다) 를 구조화하여 수정하기 쉽게하는 방법을 보여준다. 3장에서는 모나드에 의해 충족되는 법을 설명한다. 4장에서는 순수 함수언어에서 업데이트 가능한 상태(updatable state)를 제공하는 오래된 문제에 대해 모나드를 이용한 새로운 해결책을 제시한다. 5장에서는 모나드를 재귀적으로 접근하는 파서를 만드는 문제에 적용하는 것을 다룬다. 이는 그 자체로도 흥미롭지만, 시퀀싱 (sequencing) 과 교체 (alternation) 이라는 프로그래밍의 중요한 두가지 개념에 대한 새로운 패러다임을 제시한다.

여기에서 제시하는 구조화 방법들은, 카테고리 이론으로 부터의 통찰력없이는 발견될 수 없었을 것이다. 하지만, 한번 발견되면 카테고리 이론을 사용하지 않고도 쉽게 표현하고 설명할 수 있다. 이 논문을 읽기 위해 카테고리 이론 지식이 필요하지 않다.

예제는 Haskell로 제공되지만, 이에 대한 배경지식은 필요 없습니다. 필요한 것은 순수, 비순수 함수형 프로그래밍의 기초에 대한 일반적인 지식입니다. 일반적인 배경지식에 대해서는 [3,12] 를 참조하십시오. 앞으로 언급할 언어는 Haskell [4], Miranda [20], Standard ML [11] 그리고 Scheme [17]입니다.

## 2. 모나드를 사용하여 평가자 (evaluator) 만들기

함수형 언어는 모든 데이터 흐름이 명시적으로(explicit) 드러나는 장점이 있습니다. 그리고 때로는 너무나도 명시적이라는 것이 단점 입니다.

함수형 언어에서 프로그램은 식의 집합으로 작성됩니다. 명시적 데이터 흐름(explicit data flow)은 식의 값이 자유 변수(free variable)에만 의존할 수 있도록 보장합니다. 따라서 동등한 것끼리의 대체는 항상 유효하므로, 이러한 프로그램은 규명하기 쉽습니다. 명시적 데이터 흐름은 계산의 순서가 상관없기 때문에, 지연 평가(lazy evalutation)에 민감하게 됩니다.

명시적 데이터 흐름은 모듈화(modularity)에 대한 장단점을 모두 갖추고 있습니다. 데이터가 들어오고 나가는 것이 명확하고 접근할 수 있으므로 최대한 유연하기 때문에 궁극의 모듈성을 갖추고 있다고 라고 말할 수 있지만, 한편으로는 알고리즘의 본질이 데이터를 생성하는 지점에서 사용하는 지점까지 데이터를 요구하는 배관 (plumbing) 아래에 감춰져 있을 수 있기 때문에 최약의 모듈성을 갖추고 있다고 할 수 도 있습니다.

평가자 (evaluator) 를 순수 함수형 언어로 작성한다고 해봅시다.

- 함수의 오류 처리를 추가하기 위해서는, 오류를 확인하고 적절하게 처리하도록 함수 각각의 재귀적 호출(recursive call)을 수정해야합니다. 예외(exception)를 가지는 비순수 언어를 사용했더라면, 이런 변경 작업이 필요치 않았을 것입니다.
- 함수를 재귀적으로 호출할 때마다 연산의 횟수를 세어야 하기 때문에, 각각의 재귀 호출에서 적절하게 카운트를 전달해야 합니다. 그러한 카운트를 증가시키는 전역 변수를 가진 비순수 언어를 사용한다면, 이런 변경 작업이 필요치 않았을 것입니다.
- 해당 재귀적 호출에 트레이싱(tracing)을 추가하려면, 적절한 트레이싱을 전달하도록 각 재귀 호출을 수정해야 합니다. 출력을 사이드이펙트(side effect)로 작동시킬 수 있는 비순수 언어를 사용했다면 이러한 변경 작업이 필요하지 않습니다.

혹은 모나드를 사용할 수 도 있을 것입니다.
아래 내용들은 모나드를 사용하여 평가자을 작성하는 방법을 보여줍니다. 위에서 언급한 변경 내용 대신, 모나드만을 재정의하고 일부 지역적인 변경만을 수행하면 됩니다.

이러한 프로그래밍 스타일을 통해 비순수 언어의 다양한 기능으로 제공하는 유연성을 일부분 가져올 수 있습니다. 또한 비순수한 기능을 갖추지 않았을때도 사용할 수 있습니다. 명시적 데이터에서 제공되는 유연성과 암시적 배관 연결(plumbing)에서 제공하는 간결성 사이의 긴장을 완전히 없앨 수는 없지만, 일부 개선할 수 는 있습니다.

아래에서는 간단한 용어들을 다루는 기초적인 평가자을 만드는 것으로 시작하여, 예외, 상태 및 출력을 모사할 수 있는 변경 작업을 진행해 볼 것입니다. 이 과정에서 이 작업들의 공통점을 분석하고, 이들로부터 모나드의 개념을 추출해보고자 합니다. 그 다음 각각의 변경 작업들이 모나드 라는 프레임워크에 어떻게 잘 들어맞는지를 살펴볼 것입니다.

### 2.1 0번째 변형: 간단한 평가자

이 변경작업에서는 굉장히 단순한 Term 을 다루는 평가자를 다룹니다. (i.e. Term 은 아래와 같이 새롭게 정의한 약속어, 타입(Type) 이다.)

```
data Term = Con Int | Div Term Term
```

Term 은 상수 Con a (a 는 정수) 또는 t 와 u 라는 또다른 Term 들로 이루어진 분수 Div t u 중 하나입니다. (i.e. t 와 u 가 또다른 Term 이기 때문에, 재귀적인 나누기를 수행하는 약속자라고 생각하면 될 것이다.)

이 Term 을 다루는 평가자는 아래와 같이 매우 간단합니다.

```
eval :: Term -> Int
eval(Con a) = a
eval(Div t u) = eval t ÷ eval u
```

eval 함수는 Term 을 정수로 변환합니다. Term 이 상수이면 상수가 반환됩니다. Term 이 분수 (Div t u) 이면 재귀적으로 하위 Term 이 평가되고 분수가 계산됩니다. 정수 나눗셈을 표현하기 위해 '÷'를 사용합니다.

아래는 Term 의 예시입니다.

```
answer,error :: Term
answer = (Div (Div (Con 1972 ) (Con 2 )) (Con 23 ))
error = (Div (Con 1)(Con 0))
```

첫번째 eval 함수의 결과인 answer 는 ((1972 ÷ 2 ) ÷ 23 ))의 값인 42입니다. 기본 평가자는 오류 처리를 포함하지 않으므로 두번째 eval 함수의 값 error 의 결과는 undefined 입니다.

### 2.2 1번째 변형: 예외처리

오류 처리를 추가하고자 한다면, 위의 두 번째 예제에서 옳은 오류 메시지를 반환하도록 할 수 있습니다. 비순수 언어에서는 예외(exception)를 사용하여 이를 쉽게 이를 수행할 수 있습니다.

순수 언어로 예외 처리를 모방하기 위해서는 예외를 발생시킬 수 있는 연산을 나타내는 타입을 만들어야 한다.

```
data M a = Raise Exception | Return a
type Exception = String
```

타입 M a 의 값은 Raise e 이거나 Return a 의 형식이다. e는 예외이고, a는 타입 a의 값이다. 관례상, a는 M a와 같이 타입 변수로도, Return a와 같이 그 타입의 값을 의미하는 변수로도 사용된다.
('데이터 Data'와 '타입 Type' 선언의 차이점에 대해 한마디 하자면. '데이터' 선언은 위 경우의 M과 같은 새로운 데이터 유형을 소개하거나, 위 경우의 Raise 와 Return 같이 해당 타입의 값에 대한 새로운 생성자를 소개하는 것이다. '타입' 선언은 위의 Exception 이 String 의 다른 이름인 것처럼, 기존에 존재하는 타입에 대한 새로운 이름을 소개하는 것이다.)
평가자에 이러한 표현을 적용하는 것은 직관적이기는 하지만 지루한 일이다.

```
eval :: Term -> M Int
eval(Con a) = Return a
eval(Div t u) = case eval t of
  Raise e -> Raise e
  Return a ->
    case eval u of
      Raise e -> Raise e
      Return b ->
        if b = 0
          then Raise "divide by zero"
          else Return (a ÷ b)
```

평가자의 각 호출에서 결과의 형식을 점검해야 합니다. 예외가 발생하면 예외를 다시 제기하고, 값이 반환되면 진행합니다. answer에 새 평가자를 적용하면 (Return 42)이 반환되고, error에 적용하면 (Raise "divide by zero")이 반환됩니다.

### 2.3 2번째 번형: 상태

잠시 오류에 대해서는 잊고, 평가자 수행 과정중에 발생한 나누기 계산의 횟수를 세려고 한다. 비순수 언어에서는 상태를 사용하여 쉽게 이를 수행할 수 있다. 주어진 변수를 초기 값을 0으로 설정하고, 하나의 나누기 연산이 일어날 때마다 1씩 증가시키면 된다.
순수 언어에서는 상태에 작용하는 연산을 표현하는 유형을 통해 상태를 모방할 수 있다.

```
type M a = State -> (a,State)
type State = Int
```

이제 타입 M의 값 a는 초기 상태를 받아, 최종 상태와 연산 결과의 쌍을 반환하는 함수이다.

다시한번 평가자에 이를 적용하는 것은 간단하지만 지루한 작업이다.

```
eval :: Term -> M Int
eval(Con a) x = (a, x)
eval(Div t u) x =let (a,y) = eval t x in
  let (b, z) = eval u y in (a ÷ b, z + 1)
```

평가자가 호출될 때마다, 오래된 상태 값이 전달되고, 결과로부터 추출된 새로운 상태 값이 알맞게 반환된다.
평가자에 answer 와 0 를 입력하면 (42,2) 가 반환된다. 즉 0 이 상태의 초기 값으로 주어졌을때 answer 는 42 이고, 최종 상태는 2 이며, 즉 2번의 나누기가 수행되었다는 것을 의미한다.

### 2.4 3번째 변형: 아웃풋

마지막으로 실행내용을 추적하여 표시하려고 한다. 비순수 언어에서는 알맞은 위치에 출력 명령을 삽입함으로써 쉽게 할 수 있는 일이다.
순수 언어에서는 출력을 모방하기 위해 출력을 생성하는 계산을 나타내는 타입을 도입할 수 있다.

```
type M a =(Output, a)
type Output = String
```

이제 M a 타입의 값은 생성된 출력과 계산된 반환값의 쌍입니다.
또 한 번, 이 내용을 적용하는 것은 직관적이지만 지루한 일입니다.

```
eval :: Term -> M Int
eval(Con a) = (line(Con a) a, a)
eval(Div t u) = let (x, a) = eval t in
  let (y, b) = eval u in
    (x ++ y ++ line(Div t u) (a ÷ b), a ÷ b)
line :: Term -> Int -> Output
line t a = "eval (" ++ showterm t ++ ") <= " + showint a ++ "\n"
```

평가자의 각 호출에서 출력이 수집되어 상위 호출의 출력을 이루게 됩니다. 함수 line 은 한 줄의 출력을 생성합니다. 여기서 showterm과 showint는 용어와 정수를 문자열로 변환하고, ++ 는 문자열을 연결하고, "\n"는 줄바꿈을 포함하는 문자열입니다. (i.e. 원문에서는 ↵ 이었지만 \n 으로 대체하였습니다.)
eval anser 는 (x, 42) 라는 쌍을 반환하고 여기에서 x 는 아래와 같은 연산이 어떻게 이루어졌는지를 표현하는 문자열입니다.

```
eval (Con 1972 ) <= 1972
eval (Con 2 ) <= 2
eval (Div (Con 1972 ) (Con 2 )) <= 986
eval (Con 23 ) <= 23
eval (Div (Div (Con 1972 ) (Con 2 )) (Con 23 ))) <= 42
```

현재까지의 논의된 바를 살펴보자면, 비순수 언어의 프로그램은 순수언어의 프로그램보다 더 쉽게 수정할 수 있었습니다. 하지만 때때로 반대의 경우도 마찬가지입니다. 위의 프로그램에서 실행 트레이스를 아래와 같이 역순으로 표시하도록 수정하려고 한다고 가정해보겠습니다.

eval (Div (Div (Con 1972 ) (Con 2 )) (Con 23 ))) ⇐ 42 eval (Con 23 ) ⇐ 23
eval (Div (Con 1972 ) (Con 2 )) ⇐ 986
eval (Con 2 ) ⇐ 2
eval (Con 1972 ) ⇐ 1972

이 작업은 순수언어를 사용하면 굉장히 쉽게 이루어 질 수 있는데,

```
x ++ y ++ line(Div t u) (a ÷ b)
```

를

```
line(Div t u) (a ÷ b) ++  x ++ y
```

이렇게 바꾸기만 하면 됩니다.

이러한 수정을 비순수 언어로 작성된 프로그램에서 수행하는 것은 쉬운일이 아닙니다. 이 문제는 출력이 계산의 사이드이펙트로 발생했는데, 이제는 term 에 대한 계산의 결과를 해당 계산으로 인해 생성된 출력이 보여지기도 전에 보여주고 싶어한다는데 있습니다. (i.e. 계산의 순서와 역행되는 순서로 출력을 보여주고 싶어 한다는 의미) 물론 비순수 언어에서도 다양한 방법으로 이를 해결할 수 있습니다. 하지만, 모두 상당한 량의 수정을 필요로 합니다.

### 2.5 monad 를 사용한 평가자

위에서 살펴본 인터프리터의 변형들은 모두 비슷한 구조를 가지고 있고, 이 공통점으로 부터 모나드라는 추상적 개념을 도출해 볼 수 있다.
각각의 변형들에서 우리는 하나의 연산 타입을 소기하였는데, 각각의 경우에서 M 은 예외를 제기할 수 있었고, 상태에 작용할 수 있었고, 출력을 생성할 수 있었다. 이제 독자들은 M 이 monad 를 의미한다는 것을 추측해볼 수 있을 것이다.

평가자의 원래 타입은 Term -> Int 이지만, 각 변형에서는 Term -> M Int 형태로 표현되었습니다. 일반적으로 a -> b 타입의 함수는 a -> M b 타입의 함수로 대체됩니다. 이는 a 타입의 인수를 받아서 b 타입의 결과를 반환하는 함수이지만, 추가적으로 가능한 효과를 M으로 표현한 것입니다. 이 효과는 상태를 조작하거나 출력을 생성하거나 예외를 발생시키는 것이 있습니다.

M 타입에 대해서 어떤 종류의 연산들이 필요할까? 예제를 살펴보면 두 가지 종류를 찾을 수 있다. 첫 번째 방법은 하나의 값을 해당 값 반환하고 아무것도 하지 않는 연산으로 바꾸는 것이다.

```
unit :: a -> M a
```

두번째로는 a -> M b 타입의 함수를 M a 타입의 연산에 적용하는 것이다. 이 경우는 인수가 함수보다 앞에 오도록 작성하는 것이 편리합니다.

```
(*) :: M a -> (a -> M b) -> M b
```

모나드는 타입 생성자 M, 그리고 unit, (\*) 라는 다형성(polymorphic) 타입의 연산의 3가지 요소로 이루어진다. 이 연산들은 3장에서 살펴볼 3가지 법칙을 반드시 충족하여야 한다.

우리는 종종 아래와 같은 식으로 표시할 것이다.

```
m * λa.n
```

여기에서 m 과 n 은 표현식이고, a 는 변수이다. 식 λa.n 는 람다 함수이다. a 는 식 n 의 범위안에 갇혀있는 변수입니다.

위의 식은 다음과 같이 읽힐 수 있습니다. 연산 m을 수행하고, 결과 값에 a를 바인딩한 다음, 연산 n을 수행합니다. 타입은 유용한 안내서를 제공합니다. 타입 (\*) 으로부터 볼 수 있듯이, 연산 m 은 M a 타입 이고, 변수 a 는 타입 a 이며, 식 n 은 타입 a -> M b 이며, 전체 식은 M b 타입에 해당합니다.

다음식도 위의 내용과 같은 의미를 지닙니다.

```
let a = m in n.
```

비순수 언어에서도 동일하게 읽을 수 있습니다. 연산 m을 수행하고, 결과 값을 a 에 바인딩한 다음, 연산 n을 수행하고 그 값을 반환한다. 여기서 타입은 값과 연산을 구별하는 데 아무런 도움이 되지 않습니다. 표현식 m 은 타입 a를 가지고, 변수 a는 타입 a를 가지고, 표현식 n은 타입 b를 가지고, 전체 표현식은 타입 b를 가집니다. let 이라는 표현은 (\*) 에 입력되는 인수 들의 순서를 어떻게 선택했는지를 설명해 줍니다. 인수 m 이 함수 λa.n 이전에 나타나는 것이 편리한 방식입니다. 연산 m 이 연산 n 보다 이전에 수행되기 때문입니다.

평가자를 이러한 추상화를 이용해 쉽게 재작성해 볼 수 있습니다.

```
eval :: Term -> M Int
eval(Con a) =unit a
eval(Div t u) = eval t * λa. eval u * λb. unit (a ÷ b)
```

우선 한마디 하자면, 람다 추상화가 가장 약하게 묶이고, 이의 응용 부분이 가장 강하게 묶이므로, 마지막 방정식은 다음과 같이 표현할 수 있습니다.

```
eval (Div t u) = ((eval t) * (λa. ((eval u) * (λb. (unit (a ÷ b))))))
```

타입 Term -> M Int는 평가자가 항목을 취하고 정수를 생성하는 계산을 수행한다는 것을 의미한다. (Con a) 의 연산은, 그저 a를 반환하기만 하면 된다. (Div t u)를 계산하려면, 먼저 t를 계산하고, 결과에 a를 바인딩한 다음, u를 계산하고, 결과에 b를 바인딩한 다음, a ÷ b 라는 식의 결과 값을 반환하면 된다.

새로운 평가자는 원래 기본 평가자보다 좀 더 복잡하지만, 훨씬 유연합니다. 위에서 제시한 모든 변형들은 M, unit, \*의 정의를 수정하거나, 단지 한 두개의 지역적인 수정만 을 통해 이루어질 수 있습니다. 특히, 이러한 간단한 변경을 위해 평가자 전체를 재작성할 필요가 없습니다.

### 2.6 0번째 변형 다시 살펴보기: 기본 평가자

가장 간단한 모나드에서는 연산이 변수 그 자체이다.

```
type M a = a
unit :: a -> I a
unit a = a
(*) :: M a -> (a -> M b) -> M b
a * k = k a
```

이는 항등 (identity) 모나드로 불린다. M 은 타임들에 대한 항등 함수이고 unit 은 항등 함수이다. 그리고 \* 은 단지 이를 적용하는 부분이다.
2.5 장의 모나드 평가자에서 나왔던 M, unit 와 \* 를 단순하게 이용해 2.1장의 기본 평가자를 구성할 수 있었다.

### 2.7 1번째 변형 다시 살펴보기: 예외처리

In the exception monad, a computation may either raise an exception or return a value.
예외처리 모나드에서는 연산이 예외를 제가하거나 혹은 값을 반환할 수 있다.

```
data M a = Raise Exception | Return a
type Exception = String
unit :: a -> M a
unit a  = Return a
(*) :: M a -> (a -> M b) -> M b
m * k = case m of
  Raise e -> Raise e
  Return a -> k a
raise :: Exception -> M a
raise e = Raise e
```

함수 unit a는 값 a 를 그대로 반환합니다. 함수 m \* k는 계산 m의 결과를 살펴본 후, 만약 예외라면 예외를 다시 제기하고, 그렇지 않으면 반환한 값에 함수 k 적용합니다. 항등 모나드에서 \* 가 함수 적용 부분이라고 이었던 것처럼, 예외처리 모나드의 \*는 좀 더 구체적 함수 적용의 형태로 볼 수 있습니다. 마지막으로 함수 raise e는 예외 e를 제기합니다.

To add error handling to the monadic evaluator, take the monad as above. Then just replace unit (a ÷ b) by

2.5장의 모나드 평가자에 오류 처리를 추가하고 싶으면, `unit (a ÷ b)` 부분을 아래 처럼 변경하면 됩니다.

```
if b = 0
  then raise “divide by zero”
  else unit (a ÷ b)
```

이것은 비순수 언어에서 예외처리를 위해 필요한 변화와 일치하는 것입니다.
예상하듯이, 이 평가자는 2.2 장의 예외처리를 하는 평가자와 동일합니다. 특히 이번 장에서 등장했던 \*와 unit 의 정의들을 펼치고 단순화 하면 2.2장의 평가자가 됩니다.

### 2.8 2번째 변형 다시 살펴보기: 상태

상태 모나드에서의 연산은 초기 상태를 받아서, 결과 값을 최종 상태와 한 쌍으로 반환하는 연산을 수행합니다.

```
type Ma = State->(a,State)
type State = Int
unit :: a -> M a
unit a = λx.(a, x)
(*) :: M a -> (a -> M b) -> M b
m*k = λx. let (a, y) = m x in
  let (b,z)=kay in
    (b,z)
tick :: M ()
tick = λx.((),x+1)
```

함수 uni a 의 호출은 초기 상태 x 를 받아서 값 a 와 최종 상태 x 를 반환하는 연산 자체를 반환합니다. 즉, 이 연산은 상태는 변경하지 않고 a 만을 반환합니다. m \* k 를 호출하는 것은 초기 상태 x에서 연산 m 을 수행하여 값 a와 중간 상태 y 를 생성한 다음, 상태 y 에서 연산 k a 를 수행하여 값 b와 최종 상태 z를 생성합니다. tick을 호출하는 것은 상태 값을 증가시키고, 빈 결과 값 () 을 반환합니다. 이 값의 타입 또한 ()로 표시됩니다.

비순수 언어에서는 tick과 같은 작업은 () -> () 타입의 함수로 표현됩니다. 가짜 인수 ()는 함수가 적용될 때까지 효과를 지연시키기 위해 필요하며, 출력 타입이 () 이므로 함수의 목적이 사이드이펙트에 있음을 추측할 수 있습니다. 반면에 여기에서 사용된 tick은 타입 M () 을 갖는데, 가짜 인수가 필요하지 않으며, M 의 명확한 표현함으로써 어떤 종류의 효과가 발생할 수 있음을 명확하게 나타냅니다.

모나드 평가자에 연산 횟수를 카운트하기 위해서, 위에서 했던 것처럼 `unit (a ÷ b)` 를 아래와 같이 바꾸면 됩니다.

```
tick * λ(). unit (a ÷ b)
```

(여기에서 값이 ()인 하나의 새로운 변수 x 를 이용하여, λ. e 를 λx. e로 대체할 수 있다. 이는 람다 표현에 갇혀있는 값이 반드시 ()여야 된다는 것을 의미한다.) 또 아시 이는 비순수 언어에서 필요한 변경 내용과 일치한다. 간단히 하는 과정만을 거치면, 2.3 절의 상태 평가자를 만들 수 있다.

### 2.9 3번째 변형 다시 살펴보기: 출력

출력 모나드에서의 연산은 결과 값과 출력의 쌍을 반환한다.

```
type M a = (Output, a)
type Output = String
unit :: a → M a
unit a = ("", a)
(*) :: M a → (a → M b) → M b
m * k = let (x, a) = m in
  let (y, b) = k a in
  (x ++ y, b)
out :: Output → M ()
out x = (x , ())
```

unit a 를 호출하는 것은 값 a와 비어있는 출력 쌍을 반환한다. m \* k 를 호출하는 것은 계산 m 으로부터 출력 x와 값 a를 추출하고, 계산 k a에서 출력 y와 값 b를 추출하여 x와 y를 이어 붙인 출력과 값 b를 쌍으로 반환합니다. out x 를 호출하면 출력 x 와 빈 값 ()로 구성된 연산을 반환합니다.

모나드 평가자에 이러한 기능을 추가하기 위해서는, 2.5장의 모나드에서 Con a 에 대한 구절에서의 unit a 부분을 아래 내용으로 치환하고

```
out (line (Con a) a) * λ(). unit a
```

Div t u 에 대한 구절에서의 unit (a ÷ b) 부분을 아래 내용으로 치환 하면 된다.

```
out (line (Div t u) (a ÷ b)) * λ(). unit (a ÷ b)
```

또 한 번, 이러한 내용은 비순수 언어에서 필요한 변화에 상응하는 내용이며. 프로그램 작성내용을 간단히 정리하면 2.4 장의 출력 평가자가 됩니다.
연산의 수행내용들을 역순으로 출력하려면, \* 의 정의를 x++y 에서 y++x 바꾸면 된다. 이것은 순수 언어 프로그램에서 가능한 변화이며, 비순수 언어 프로그램에서 필요로 하는 변화 내용보다 훨씬 간단합니다.

아마도 당신은 순수버젼와 비순수 버젼의 차이가 단순히 순수 버젼은 계산이 끝날때까지 아무것도 보여주지 않고, 비순수 버젼은 계산 할때마다 출력을 보여주는 차이라고 생각할 수 도 있습니다.

하지만 사실, 순수 언어가 지연 평가 방식을 사용하면, 출력은 계산이 일어나는 과정에서 증가하는 방식으로 나타납니다. 더군다나, 이것은 비순수 언어에서 구현하기 어려웠던 출력 순서를 반대로 하는 경우에도 마찬가지 입니다. 실제로 가장 쉬운 구현 방법은 지연 평가 방식를 시뮬레이션하는 것입니다.

## 3. 모나드 법칙

모나드의 연산은 세가지 법칙을 만족해야 합니다.

(i.e. 아래 법칙을 살피기 전에 모나드를 `m * λa. n` 이와 같이 표현했던 것을 기억하자.)

- 왼쪽 항등법칙. (i.e. 연산 m 이 unit 함수 인 경우의 계산) a 값을 계산하고, 결과에 b를 바인딩하고 그 후, n을 계산하십시오. 그 결과는 값 a 를 변수 b로 대체한 연산 n과 동일합니다.

```
unit a * λb. n = n[a/b].
```

- 오른쪽 항등법칙. (i.e. 연산 n 이 unit 함수 인 경우의 계산) m 을 계산하고 그 결과를 a에 바인딩하고 a를 반환합니다. 그 결과는 m과 동일합니다.

```
m * λa. unit a = m.
```

- 결합법칙. m을 계산하고, 그 결과를 a에 바인딩하고, n을 계산하고, 그 결과를 b에 바인딩하고, o를 계산한다. 이러한 계산에서 괄호의 순서는 중요하지 않습니다.

```
m * (λa. n * λb. o) = (m * λa. n) * λb. o.
```

변수 a의 범위는 왼쪽에서 o를 포함하지만 오른쪽에서는 o를 제외하므로, 이 법칙은 a가 o에서 자유롭지 않은 경우에만 유효합니다.

두 개의 왼쪽, 오른쪽 항등 법칙과 결합법칙을 만족하는 이항 연산을 모노이드라고 부릅니다. 모나드는 모노이드와 달리 오른쪽 연산자에 바인딩 연산이 포함되어 있습니다.
이러한 법칙의 유용성을 증명하기 위해 덧셈이 결합성을 가지는지 증명해보겠습니다. 나눗셈이 아닌 덧셈을 기반으로하는 평가자의 변형을 생각해 보도록 합시다.

```
data Term = = Con Int | Add Term Term
eval :: Term -> M Int
eval (Con a) = unit a
eval (Add t u) = eval t * λa. eval u * λb. unit (a + b)
```

(i.e. 본문에서 unit(a+b) 부분이 unit(a÷b) 로 되어 있는데, 아무래도 오타인 것 같아 수정함)

우리는 위에서

```
Add t (Add u v) and Add (Add t u) v
```

이 두가지가 같은 결과로 계산된 다는 것을 보였다.
왼쪽 항을 정리하자면

```
  eval (Add t (Add u v))
= { def’n eval }
  eval t * λa . eval (Add u v ) * λx . unit (a + x )
= { def’n eval }
  eval t * λa . (eval u * λb . eval v * λc . unit (b + c )) * λx . unit (a + x )
= { associative }
  eval t * λa . eval u * λb . eval v * λc . unit (b + c ) * λx . unit (a + x )
= { left unit }
  eval t * λa. eval u * λb. eval v * λc. unit (a + (b + c))
```

오른쪽 항을 정리하면

```
  eval (Add (Add t u) v)
= { as before }
  eval t * λa. eval u * λb. eval v * λc. unit ((a + b) + c)
```

두 결과가 덧셈의 결합법칙을 이용하면 같다는 것을 확인할 수 있습니다. 이 증명은 단순합니다; 모나드 법칙이 없으면 불가능한 작업입니다.
이러한 증명은 예외, 상태, 출력을 포함한 모든 모나드에서 수행될 수 있습니다. 이것은 코드가 위와 같은 경우를 가정합니다. 코드가 바뀐다면 증명도 수정되어야 합니다. 2.3장 에서 우리는 tick을 호출하도록 코드를 수정했습니다. 이 경우 결합법칙은 여전히 보장되며, 다음과 같은 법칙을 사용하여 증명할 수 있습니다.

```
tick ⋆ λ(). m = m ⋆ λ(). tick
```

위와같 은 증명은 tick 이 m 에 종속된 상태에만 영향을 미친다는 가정하에 유효합니다. 2.4장에서는 프로그램에 line 함수의 호출을 추가하는 수정작업을 진행했습니다. 이 경우 해당 수정작업은 결합법칙을 따르지 않습니다. 괄호의 위치를 바꾸게 되면, 연산을 추적하는 출력이 벼뀌게 되겠지만 출력 외의 값에 대한 계산은 여전히 같은 값을 생성합니다.
다른 예로, 각각의 모나드에 대해 다음 작업을 정의할 수 있습니다.

```
map :: (a -> b) -> (M a -> M b)
map f m = m * λa. unit (f a)
join :: M (M a) -> M a
join z = z * λm. m
```

이 map 연산은 단지 함수를 계산한 결과에 적용하는 것입니다. map f m을 계산하려면, 먼저 m을 계산하고, a에 그 결과를 바인딩한 다음, f a를 반환하면 됩니다. join 연산은 더 복잡합니다. z는 자신이 생성하는 계산에 계산 자체가 되는 것 입니다. join z를 계산하려면, 먼저 z를 계산하고, m 에 그 결과를 바인딩한 다음, m 이 계산되는 것처럼 동작합니다. 이를 통해, join 은 머리를 복잡하게 만드는 2개의 층을 가진 계산을 평범한 한개의 층만을 가진 계산으로 펼칠 수 있습니다. 5.1장에서 앞으로, 리스트 모나드이고, 이 모나드에서 map 은 리스트의 각 요소에 함수를 적용하고, join 은 리스트안의 리스트를 합치는 것을 보게 될 것입니다.
항등함수 `(id x = x)` id 와 함수 합성`((f · g) x = f (g x))` (·)를 사용하면 아래와 같은 다양한 법칙을 표현할 수 있습니다.

```
map id = id
map(f · g) = map f · map g
map f · unit = unit·f
map f · join = join · map (map f)
join · unit = id
join · map unit = id
join · map join = join · join
m * k = join (map k m)
```

각 법칙에 대한 증명은 map 과 join 의 정의, 그리고 모나드의 세가지 법칙을 이용해 간단하게 도출할 수 있습니다.

대부분의 경우, 모나드는 unit 위와 \* 를 이용한 정의 대신에 unit, join, 그리고 map 을 기반으로 정의됩니다 [10,13]. 위에서 살펴본 세가지 모나드 법칙은 위의 여덟 번째까지 법칙 중 처음 일곱가지 법칙으로 대체될 수 있습니다. 만약 \* 을 여덟 번째 법칙으로 정의한다면, 세 가지 모나드 법칙을 따라, 두 가지 방식의 정의는 동등하게 됩니다.
